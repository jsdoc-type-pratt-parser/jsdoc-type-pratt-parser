{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/lexer/Lexer.ts","../src/assertTypes.ts","../src/Parser.ts","../src/parslets/isQuestionMarkUnknownType.ts","../src/parslets/NullableParslets.ts","../src/parslets/Parslet.ts","../src/parslets/OptionalParslet.ts","../src/parslets/NumberParslet.ts","../src/parslets/ParenthesisParslet.ts","../src/parslets/SpecialTypesParslet.ts","../src/parslets/NotNullableParslet.ts","../src/parslets/ParameterListParslet.ts","../src/parslets/GenericParslet.ts","../src/parslets/UnionParslets.ts","../src/grammars/baseGrammar.ts","../src/parslets/NamePathParslet.ts","../src/parslets/NameParslet.ts","../src/parslets/StringValueParslet.ts","../src/parslets/SpecialNamePathParslet.ts","../src/grammars/pathGrammar.ts","../src/parslets/FunctionParslet.ts","../src/parslets/VariadicParslet.ts","../src/parslets/SymbolParslet.ts","../src/parslets/ArrayBracketsParslet.ts","../src/parslets/ObjectParslet.ts","../src/parslets/ObjectFieldParslet.ts","../src/parslets/KeyValueParslet.ts","../src/grammars/jsdocGrammar.ts","../src/parslets/TypeOfParslet.ts","../src/grammars/closureGrammar.ts","../src/parslets/assertsParslet.ts","../src/parslets/TupleParslet.ts","../src/parslets/KeyOfParslet.ts","../src/parslets/ImportParslet.ts","../src/parslets/ReadonlyPropertyParslet.ts","../src/parslets/ArrowFunctionParslet.ts","../src/parslets/GenericArrowFunctionParslet.ts","../src/parslets/IntersectionParslet.ts","../src/parslets/predicateParslet.ts","../src/parslets/ObjectSquaredPropertyParslet.ts","../src/parslets/ReadonlyArrayParslet.ts","../src/parslets/ConditionalParslet.ts","../src/grammars/typescriptGrammar.ts","../src/parse.ts","../src/transforms/transform.ts","../src/transforms/stringify.ts","../src/transforms/catharsisTransform.ts","../src/transforms/jtpTransform.ts","../src/transforms/identityTransformRules.ts","../src/visitorKeys.ts","../src/traverse.ts"],"sourcesContent":["/**\n * @package\n * This package provides a parser for jsdoc types.\n */\n\nexport * from './parse'\nexport type * from './result/RootResult'\nexport type * from './result/NonRootResult'\nexport { transform, type TransformRule, type TransformFunction, type TransformRules } from './transforms/transform'\nexport { catharsisTransform } from './transforms/catharsisTransform'\nexport { jtpTransform } from './transforms/jtpTransform'\nexport { stringify, stringifyRules } from './transforms/stringify'\nexport { identityTransformRules } from './transforms/identityTransformRules'\nexport * from './traverse'\nexport * from './visitorKeys'\n","import type { Token } from './lexer/Token'\nimport type { IntermediateResult } from './result/IntermediateResult'\n\nfunction tokenToString (token: Token): string {\n  if (token.text !== undefined && token.text !== '') {\n    return `'${token.type}' with value '${token.text}'`\n  } else {\n    return `'${token.type}'`\n  }\n}\n\nexport class NoParsletFoundError extends Error {\n  private readonly token: Token\n\n  constructor (token: Token) {\n    super(`No parslet found for token: ${tokenToString(token)}`)\n\n    this.token = token\n\n    Object.setPrototypeOf(this, NoParsletFoundError.prototype)\n  }\n\n  getToken (): Token {\n    return this.token\n  }\n}\n\nexport class EarlyEndOfParseError extends Error {\n  private readonly token: Token\n\n  constructor (token: Token) {\n    super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n\n    this.token = token\n\n    Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n  }\n\n  getToken (): Token {\n    return this.token\n  }\n}\n\nexport class UnexpectedTypeError extends Error {\n  constructor (result: IntermediateResult, message?: string) {\n    let error = `Unexpected type: '${result.type}'.`\n    if (message !== undefined) {\n      error += ` Message: ${message}`\n    }\n    super(error)\n\n    Object.setPrototypeOf(this, UnexpectedTypeError.prototype)\n  }\n}\n\n// export class UnexpectedTokenError extends Error {\n//   private expected: Token\n//   private found: Token\n//\n//   constructor (expected: Token, found: Token) {\n//     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n//\n//     this.token = token\n//\n//     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n//   }\n//\n//   getToken() {\n//     return this.token\n//   }\n// }\n","import type { Token, TokenType } from './Token'\n\ntype PartialToken = Omit<Token, 'startOfLine'>\n\ntype Rule = (text: string) => PartialToken | null\n\nfunction makePunctuationRule (type: TokenType): Rule {\n  return text => {\n    if (text.startsWith(type)) {\n      return { type, text: type }\n    } else {\n      return null\n    }\n  }\n}\n\nfunction getQuoted (text: string): string | null {\n  let position = 0\n  let char = undefined\n  const mark = text[0]\n  let escaped = false\n\n  if (mark !== '\\'' && mark !== '\"') {\n    return null\n  }\n\n  while (position < text.length) {\n    position++\n    char = text[position]\n    if (!escaped && char === mark) {\n      position++\n      break\n    }\n    escaped = !escaped && char === '\\\\'\n  }\n\n  if (char !== mark) {\n    throw new Error('Unterminated String')\n  }\n\n  return text.slice(0, position)\n}\n\nconst identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u\n// A hyphen is not technically allowed, but to keep it liberal for now,\n//  adding it here\nconst identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u\nfunction getIdentifier (text: string): string | null {\n  let char = text[0]\n  if (!identifierStartRegex.test(char)) {\n    return null\n  }\n  let position = 1\n  do {\n    char = text[position]\n    if (!identifierContinueRegex.test(char)) {\n      break\n    }\n    position++\n  } while (position < text.length)\n  return text.slice(0, position)\n}\n\n// we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\nconst numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/\nfunction getNumber (text: string): string | null {\n  return numberRegex.exec(text)?.[0] ?? null\n}\n\nconst identifierRule: Rule = text => {\n  const value = getIdentifier(text)\n  if (value == null) {\n    return null\n  }\n\n  return {\n    type: 'Identifier',\n    text: value\n  }\n}\n\nfunction makeKeyWordRule (type: TokenType): Rule {\n  return text => {\n    if (!text.startsWith(type)) {\n      return null\n    }\n    const prepends = text[type.length]\n    if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n      return null\n    }\n    return {\n      type,\n      text: type\n    }\n  }\n}\n\nconst stringValueRule: Rule = text => {\n  const value = getQuoted(text)\n  if (value == null) {\n    return null\n  }\n  return {\n    type: 'StringValue',\n    text: value\n  }\n}\n\nconst eofRule: Rule = text => {\n  if (text.length > 0) {\n    return null\n  }\n  return {\n    type: 'EOF',\n    text: ''\n  }\n}\n\nconst numberRule: Rule = text => {\n  const value = getNumber(text)\n  if (value === null) {\n    return null\n  }\n  return {\n    type: 'Number',\n    text: value\n  }\n}\n\nconst rules: Rule[] = [\n  eofRule,\n  makePunctuationRule('=>'),\n  makePunctuationRule('('),\n  makePunctuationRule(')'),\n  makePunctuationRule('{'),\n  makePunctuationRule('}'),\n  makePunctuationRule('['),\n  makePunctuationRule(']'),\n  makePunctuationRule('|'),\n  makePunctuationRule('&'),\n  makePunctuationRule('<'),\n  makePunctuationRule('>'),\n  makePunctuationRule(','),\n  makePunctuationRule(';'),\n  makePunctuationRule('*'),\n  makePunctuationRule('?'),\n  makePunctuationRule('!'),\n  makePunctuationRule('='),\n  makePunctuationRule(':'),\n  makePunctuationRule('...'),\n  makePunctuationRule('.'),\n  makePunctuationRule('#'),\n  makePunctuationRule('~'),\n  makePunctuationRule('/'),\n  makePunctuationRule('@'),\n  makeKeyWordRule('undefined'),\n  makeKeyWordRule('null'),\n  makeKeyWordRule('function'),\n  makeKeyWordRule('this'),\n  makeKeyWordRule('new'),\n  makeKeyWordRule('module'),\n  makeKeyWordRule('event'),\n  makeKeyWordRule('extends'),\n  makeKeyWordRule('external'),\n  makeKeyWordRule('infer'),\n  makeKeyWordRule('typeof'),\n  makeKeyWordRule('keyof'),\n  makeKeyWordRule('readonly'),\n  makeKeyWordRule('import'),\n  makeKeyWordRule('is'),\n  makeKeyWordRule('in'),\n  makeKeyWordRule('asserts'),\n  numberRule,\n  identifierRule,\n  stringValueRule\n]\n\nconst breakingWhitespaceRegex = /^\\s*\\n\\s*/\n\nexport class Lexer {\n  private readonly text: string = ''\n  public readonly current: Token\n  public readonly next: Token\n  public readonly previous: Token | undefined\n\n  public static create (text: string): Lexer {\n    const current = this.read(text)\n    text = current.text\n    const next = this.read(text)\n    text = next.text\n    return new Lexer(text, undefined, current.token, next.token)\n  }\n\n  private constructor (text: string, previous: Token | undefined, current: Token, next: Token) {\n    this.text = text\n    this.previous = previous\n    this.current = current\n    this.next = next\n  }\n\n  private static read (text: string, startOfLine = false): { text: string, token: Token } {\n    startOfLine ||= breakingWhitespaceRegex.test(text)\n    text = text.trim()\n    for (const rule of rules) {\n      const partial = rule(text)\n      if (partial !== null) {\n        const token = {\n          ...partial,\n          startOfLine\n        }\n        text = text.slice(token.text.length)\n        return { text, token }\n      }\n    }\n    throw new Error('Unexpected Token ' + text)\n  }\n\n  advance (): Lexer {\n    const next = Lexer.read(this.text)\n    return new Lexer(next.text, this.current, this.next, next.token)\n  }\n}\n","import type { IndexSignatureResult, KeyValueResult, MappedTypeResult } from './result/NonRootResult'\nimport { UnexpectedTypeError } from './errors'\nimport type { NameResult, NumberResult, RootResult, VariadicResult, TupleResult, GenericResult } from './result/RootResult'\nimport type { IntermediateResult } from './result/IntermediateResult'\n\n/**\n * Throws an error if the provided result is not a {@link RootResult}\n */\nexport function assertRootResult (result?: IntermediateResult): RootResult {\n  if (result === undefined) {\n    throw new Error('Unexpected undefined')\n  }\n  if (\n    result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n    result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n    result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n    result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType' ||\n    result.type === 'JsdocTypeTypeParameter'\n  ) {\n    throw new UnexpectedTypeError(result)\n  }\n  return result\n}\n\nexport function assertPlainKeyValueOrRootResult (result: IntermediateResult): KeyValueResult | RootResult {\n  if (result.type === 'JsdocTypeKeyValue') {\n    return assertPlainKeyValueResult(result)\n  }\n  return assertRootResult(result)\n}\n\nexport function assertPlainKeyValueOrNameResult (result: IntermediateResult): KeyValueResult | NameResult {\n  if (result.type === 'JsdocTypeName') {\n    return result\n  }\n  return assertPlainKeyValueResult(result)\n}\n\nexport function assertPlainKeyValueResult (result: IntermediateResult): KeyValueResult {\n  if (result.type !== 'JsdocTypeKeyValue') {\n    throw new UnexpectedTypeError(result)\n  }\n  return result\n}\n\nexport function assertNumberOrVariadicNameResult (result: IntermediateResult): NumberResult | NameResult | VariadicResult<NameResult> {\n  if (result.type === 'JsdocTypeVariadic') {\n    if (result.element?.type === 'JsdocTypeName') {\n      return result as VariadicResult<NameResult>\n    }\n    throw new UnexpectedTypeError(result)\n  }\n  if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n    throw new UnexpectedTypeError(result)\n  }\n  return result\n}\n\nexport function assertArrayOrTupleResult (result: IntermediateResult): TupleResult | GenericResult {\n  if (result.type === 'JsdocTypeTuple') {\n    return result\n  }\n\n  if (result.type === 'JsdocTypeGeneric' && result.meta.brackets === 'square') {\n    return result\n  }\n\n  throw new UnexpectedTypeError(result)\n}\n\nexport function isSquaredProperty (result: IntermediateResult): result is IndexSignatureResult | MappedTypeResult {\n  return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType'\n}\n","import { EarlyEndOfParseError, NoParsletFoundError } from './errors'\nimport { Lexer } from './lexer/Lexer'\nimport type { Grammar } from './grammars/Grammar'\nimport { assertRootResult } from './assertTypes'\nimport { Precedence } from './Precedence'\nimport type { RootResult } from './result/RootResult'\nimport type { IntermediateResult } from './result/IntermediateResult'\nimport type { TokenType } from './lexer/Token'\n\nexport class Parser {\n  private readonly grammar: Grammar\n  private _lexer: Lexer\n  public readonly baseParser?: Parser\n\n  constructor (grammar: Grammar, textOrLexer: string | Lexer, baseParser?: Parser) {\n    this.grammar = grammar\n    if (typeof textOrLexer === 'string') {\n      this._lexer = Lexer.create(textOrLexer)\n    } else {\n      this._lexer = textOrLexer\n    }\n    this.baseParser = baseParser\n  }\n\n  get lexer (): Lexer {\n    return this._lexer\n  }\n\n  /**\n   * Parses a given string and throws an error if the parse ended before the end of the string.\n   */\n  parse (): RootResult {\n    const result = this.parseType(Precedence.ALL)\n    if (this.lexer.current.type !== 'EOF') {\n      throw new EarlyEndOfParseError(this.lexer.current)\n    }\n    return result\n  }\n\n  /**\n   * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n   */\n  public parseType (precedence: Precedence): RootResult {\n    return assertRootResult(this.parseIntermediateType(precedence))\n  }\n\n  /**\n   * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n   * to parse the state in the infix step.\n   */\n  public parseIntermediateType (precedence: Precedence): IntermediateResult {\n    const result = this.tryParslets(null, precedence)\n\n    if (result === null) {\n      throw new NoParsletFoundError(this.lexer.current)\n    }\n\n    return this.parseInfixIntermediateType(result, precedence)\n  }\n\n  /**\n   * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n   * a result.\n   */\n  public parseInfixIntermediateType (left: IntermediateResult, precedence: Precedence): IntermediateResult {\n    let result = this.tryParslets(left, precedence)\n\n    while (result !== null) {\n      left = result\n      result = this.tryParslets(left, precedence)\n    }\n\n    return left\n  }\n\n  /**\n   * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n   */\n  private tryParslets (left: IntermediateResult | null, precedence: Precedence): IntermediateResult | null {\n    for (const parslet of this.grammar) {\n      const result = parslet(this, precedence, left)\n      if (result !== null) {\n        return result\n      }\n    }\n    return null\n  }\n\n  /**\n   * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n   * advanced.\n   */\n  public consume (types: TokenType | TokenType[]): boolean {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    if (types.includes(this.lexer.current.type)) {\n      this._lexer = this.lexer.advance()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  public acceptLexerState (parser: Parser): void {\n    this._lexer = parser.lexer\n  }\n}\n","import type { TokenType } from '../lexer/Token'\n\nexport function isQuestionMarkUnknownType (next: TokenType): boolean {\n  return next === '}' || next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>'\n}\n","import type { ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { isQuestionMarkUnknownType } from './isQuestionMarkUnknownType'\nimport { assertRootResult } from '../assertTypes'\n\nexport const nullableParslet: ParsletFunction = (parser, precedence, left) => {\n  const type = parser.lexer.current.type\n  const next = parser.lexer.next.type\n\n  const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n    ((left != null) && type === '?')\n\n  if (!accept) {\n    return null\n  }\n\n  parser.consume('?')\n\n  if (left == null) {\n    return {\n      type: 'JsdocTypeNullable',\n      element: parser.parseType(Precedence.NULLABLE),\n      meta: {\n        position: 'prefix'\n      }\n    }\n  } else {\n    return {\n      type: 'JsdocTypeNullable',\n      element: assertRootResult(left),\n      meta: {\n        position: 'suffix'\n      }\n    }\n  }\n}\n","import type { TokenType } from '../lexer/Token'\nimport type { Parser } from '../Parser'\nimport type { Precedence } from '../Precedence'\nimport type { IntermediateResult } from '../result/IntermediateResult'\n\n/**\n * Each ParsletFunction can be called during the prefix or infix parsing step. In the prefix parsing step the `left` value\n * will be null and in the infix parsing step it value contain the previous value.\n * If the current state of the lexer in the current step is not accepted then the function should return `null`.\n * In the infix parsing step the current precedence should be checked.\n * See {@link composeParslet} for a more convenient way to use this function.\n */\nexport type ParsletFunction = (parser: Parser, precedence: Precedence, left: IntermediateResult | null) => IntermediateResult | null\n\ninterface BaseComposeParsletOptions {\n  name: string\n  accept: (type: TokenType, next: TokenType) => boolean\n}\n\ntype ComposePrefixParsletOptions = BaseComposeParsletOptions & {\n  parsePrefix: (parser: Parser) => IntermediateResult\n}\n\ntype ComposeInfixParsletOptions = BaseComposeParsletOptions & {\n  precedence: Precedence\n  parseInfix: (parser: Parser, left: IntermediateResult) => IntermediateResult\n}\n\nexport type ComposeParsletOptions = ComposePrefixParsletOptions | ComposeInfixParsletOptions | (ComposePrefixParsletOptions & ComposeInfixParsletOptions)\n\nexport function composeParslet (options: ComposeParsletOptions): ParsletFunction {\n  const parslet: ParsletFunction = (parser, curPrecedence, left) => {\n    const type = parser.lexer.current.type\n    const next = parser.lexer.next.type\n\n    if (left === null) {\n      if ('parsePrefix' in options) {\n        if (options.accept(type, next)) {\n          return options.parsePrefix(parser)\n        }\n      }\n    } else {\n      if ('parseInfix' in options) {\n        if (options.precedence > curPrecedence && options.accept(type, next)) {\n          return options.parseInfix(parser, left)\n        }\n      }\n    }\n    return null\n  }\n\n  // for debugging\n  Object.defineProperty(parslet, 'name', {\n    value: options.name\n  })\n\n  return parslet\n}\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const optionalParslet = composeParslet({\n  name: 'optionalParslet',\n  accept: type => type === '=',\n  precedence: Precedence.OPTIONAL,\n  parsePrefix: parser => {\n    parser.consume('=')\n    return {\n      type: 'JsdocTypeOptional',\n      element: parser.parseType(Precedence.OPTIONAL),\n      meta: {\n        position: 'prefix'\n      }\n    }\n  },\n  parseInfix: (parser, left) => {\n    parser.consume('=')\n    return {\n      type: 'JsdocTypeOptional',\n      element: assertRootResult(left),\n      meta: {\n        position: 'suffix'\n      }\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\n\nexport const numberParslet = composeParslet({\n  name: 'numberParslet',\n  accept: type => type === 'Number',\n  parsePrefix: parser => {\n    const value = parseFloat(parser.lexer.current.text)\n    parser.consume('Number')\n    return {\n      type: 'JsdocTypeNumber',\n      value\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const parenthesisParslet = composeParslet({\n  name: 'parenthesisParslet',\n  accept: type => type === '(',\n  parsePrefix: parser => {\n    parser.consume('(')\n    if (parser.consume(')')) {\n      return {\n        type: 'JsdocTypeParameterList',\n        elements: []\n      }\n    }\n    const result = parser.parseIntermediateType(Precedence.ALL)\n    if (!parser.consume(')')) {\n      throw new Error('Unterminated parenthesis')\n    }\n    if (result.type === 'JsdocTypeParameterList') {\n      return result\n    } else if (result.type === 'JsdocTypeKeyValue') {\n      return {\n        type: 'JsdocTypeParameterList',\n        elements: [result]\n      }\n    }\n    return {\n      type: 'JsdocTypeParenthesis',\n      element: assertRootResult(result)\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { isQuestionMarkUnknownType } from './isQuestionMarkUnknownType'\n\nexport const specialTypesParslet = composeParslet({\n  name: 'specialTypesParslet',\n  accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n    type === 'null' || type === 'undefined' || type === '*',\n  parsePrefix: parser => {\n    if (parser.consume('null')) {\n      return {\n        type: 'JsdocTypeNull'\n      }\n    }\n\n    if (parser.consume('undefined')) {\n      return {\n        type: 'JsdocTypeUndefined'\n      }\n    }\n\n    if (parser.consume('*')) {\n      return {\n        type: 'JsdocTypeAny'\n      }\n    }\n\n    if (parser.consume('?')) {\n      return {\n        type: 'JsdocTypeUnknown'\n      }\n    }\n\n    throw new Error('Unacceptable token: ' + parser.lexer.current.text)\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const notNullableParslet = composeParslet({\n  name: 'notNullableParslet',\n  accept: type => type === '!',\n  precedence: Precedence.NULLABLE,\n  parsePrefix: parser => {\n    parser.consume('!')\n    return {\n      type: 'JsdocTypeNotNullable',\n      element: parser.parseType(Precedence.NULLABLE),\n      meta: {\n        position: 'prefix'\n      }\n    }\n  },\n  parseInfix: (parser, left) => {\n    parser.consume('!')\n    return {\n      type: 'JsdocTypeNotNullable',\n      element: assertRootResult(left),\n      meta: {\n        position: 'suffix'\n      }\n    }\n  }\n})\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertPlainKeyValueOrRootResult } from '../assertTypes'\nimport { NoParsletFoundError } from '../errors'\nimport type { KeyValueResult } from '..'\nimport type { RootResult } from '../result/RootResult'\n\nexport function createParameterListParslet ({ allowTrailingComma }: {\n  allowTrailingComma: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'parameterListParslet',\n    accept: type => type === ',',\n    precedence: Precedence.PARAMETER_LIST,\n    parseInfix: (parser, left) => {\n      const elements: Array<RootResult | KeyValueResult> = [\n        assertPlainKeyValueOrRootResult(left)\n      ]\n      parser.consume(',')\n      do {\n        try {\n          const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST)\n          elements.push(assertPlainKeyValueOrRootResult(next))\n        } catch (e) {\n          if (allowTrailingComma && e instanceof NoParsletFoundError) {\n            break\n          } else {\n            throw e\n          }\n        }\n      } while (parser.consume(','))\n\n      if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n        throw new Error('Only the last parameter may be a rest parameter')\n      }\n\n      return {\n        type: 'JsdocTypeParameterList',\n        elements\n      }\n    }\n  })\n}\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\nimport { UnexpectedTypeError } from '../errors'\n\nexport const genericParslet = composeParslet({\n  name: 'genericParslet',\n  accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n  precedence: Precedence.GENERIC,\n  parseInfix: (parser, left) => {\n    const dot = parser.consume('.')\n    parser.consume('<')\n\n    const objects = []\n    let infer = false\n    if (parser.consume('infer')) {\n      infer = true\n      const left = parser.parseIntermediateType(Precedence.SYMBOL)\n\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript infer always has to have a name.')\n      }\n      objects.push(left)\n    } else {\n      do {\n        objects.push(parser.parseType(Precedence.PARAMETER_LIST))\n      } while (parser.consume(','))\n    }\n\n    if (!parser.consume('>')) {\n      throw new Error('Unterminated generic parameter list')\n    }\n\n    return {\n      type: 'JsdocTypeGeneric',\n      left: assertRootResult(left),\n      elements: objects,\n      ...(infer ? { infer: true } : {}),\n      meta: {\n        brackets: 'angle',\n        dot\n      }\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const unionParslet = composeParslet({\n  name: 'unionParslet',\n  accept: type => type === '|',\n  precedence: Precedence.UNION,\n  parseInfix: (parser, left) => {\n    parser.consume('|')\n\n    const elements = []\n    do {\n      elements.push(parser.parseType(Precedence.UNION))\n    } while (parser.consume('|'))\n\n    return {\n      type: 'JsdocTypeUnion',\n      elements: [assertRootResult(left), ...elements]\n    }\n  }\n})\n","import type { Grammar } from './Grammar'\nimport { nullableParslet } from '../parslets/NullableParslets'\nimport { optionalParslet } from '../parslets/OptionalParslet'\nimport { numberParslet } from '../parslets/NumberParslet'\nimport { parenthesisParslet } from '../parslets/ParenthesisParslet'\nimport { specialTypesParslet } from '../parslets/SpecialTypesParslet'\nimport { notNullableParslet } from '../parslets/NotNullableParslet'\nimport { createParameterListParslet } from '../parslets/ParameterListParslet'\nimport { genericParslet } from '../parslets/GenericParslet'\nimport { unionParslet } from '../parslets/UnionParslets'\n\nexport const baseGrammar: Grammar = [\n  nullableParslet,\n  optionalParslet,\n  numberParslet,\n  parenthesisParslet,\n  specialTypesParslet,\n  notNullableParslet,\n  createParameterListParslet({\n    allowTrailingComma: true\n  }),\n  genericParslet,\n  unionParslet,\n  optionalParslet\n]\n","import type { ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\nimport { Parser } from '../Parser'\nimport type { NamePathResult, SpecialNamePath } from '../result/RootResult'\nimport { UnexpectedTypeError } from '../errors'\nimport type { PropertyResult } from '../result/NonRootResult'\nimport type { Grammar } from '../grammars/Grammar'\n\nexport function createNamePathParslet ({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }: {\n  allowJsdocNamePaths: boolean\n  allowSquareBracketsOnAnyType: boolean\n  pathGrammar: Grammar | null\n}): ParsletFunction {\n  return function namePathParslet (parser, precedence, left) {\n    if ((left == null) || precedence >= Precedence.NAME_PATH) {\n      return null\n    }\n    const type = parser.lexer.current.type\n    const next = parser.lexer.next.type\n\n    const accept = (type === '.' && next !== '<') ||\n      (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n      (allowJsdocNamePaths && (type === '~' || type === '#'))\n\n    if (!accept) {\n      return null\n    }\n\n    let pathType: NamePathResult['pathType']\n    let brackets = false\n\n    if (parser.consume('.')) {\n      pathType = 'property'\n    } else if (parser.consume('[')) {\n      pathType = 'property-brackets'\n      brackets = true\n    } else if (parser.consume('~')) {\n      pathType = 'inner'\n    } else {\n      parser.consume('#')\n      pathType = 'instance'\n    }\n\n    const pathParser = pathGrammar !== null\n      ? new Parser(pathGrammar, parser.lexer, parser)\n      : parser\n\n    const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH)\n    parser.acceptLexerState(pathParser)\n    let right: PropertyResult | SpecialNamePath<'event'>\n\n    switch (parsed.type) {\n      case 'JsdocTypeName':\n        right = {\n          type: 'JsdocTypeProperty',\n          value: parsed.value,\n          meta: {\n            quote: undefined\n          }\n        }\n        break\n      case 'JsdocTypeNumber':\n        right = {\n          type: 'JsdocTypeProperty',\n          value: parsed.value.toString(10),\n          meta: {\n            quote: undefined\n          }\n        }\n        break\n      case 'JsdocTypeStringValue':\n        right = {\n          type: 'JsdocTypeProperty',\n          value: parsed.value,\n          meta: {\n            quote: parsed.meta.quote\n          }\n        }\n        break\n      case 'JsdocTypeSpecialNamePath':\n        if (parsed.specialType === 'event') {\n          right = parsed as SpecialNamePath<'event'>\n        } else {\n          throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'')\n        }\n        break\n      default:\n        throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'')\n    }\n\n    if (brackets && !parser.consume(']')) {\n      const token = parser.lexer.current\n      throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n        `with text '${token.text}'`)\n    }\n\n    return {\n      type: 'JsdocTypeNamePath',\n      left: assertRootResult(left),\n      right,\n      pathType\n    }\n  }\n}\n","import type { TokenType } from '../lexer/Token'\nimport { composeParslet, type ParsletFunction } from './Parslet'\n\nexport function createNameParslet ({ allowedAdditionalTokens }: {\n  allowedAdditionalTokens: TokenType[]\n}): ParsletFunction {\n  return composeParslet({\n    name: 'nameParslet',\n    accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n    parsePrefix: parser => {\n      const { type, text } = parser.lexer.current\n      parser.consume(type)\n\n      return {\n        type: 'JsdocTypeName',\n        value: text\n      }\n    }\n  })\n}\n","import { composeParslet } from './Parslet'\n\nexport const stringValueParslet = composeParslet({\n  name: 'stringValueParslet',\n  accept: type => type === 'StringValue',\n  parsePrefix: parser => {\n    const text = parser.lexer.current.text\n    parser.consume('StringValue')\n    return {\n      type: 'JsdocTypeStringValue',\n      value: text.slice(1, -1),\n      meta: {\n        quote: text.startsWith('\\'') ? 'single' : 'double'\n      }\n    }\n  }\n})\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport type { TokenType } from '../lexer/Token'\nimport { Precedence } from '../Precedence'\nimport { Parser } from '../Parser'\nimport type { SpecialNamePath, SpecialNamePathType } from '../result/RootResult'\nimport { assertRootResult } from '../assertTypes'\nimport type { Grammar } from '../grammars/Grammar'\n\nexport function createSpecialNamePathParslet ({ pathGrammar, allowedTypes }: {\n  allowedTypes: SpecialNamePathType[]\n  pathGrammar: Grammar\n}): ParsletFunction {\n  return composeParslet({\n    name: 'specialNamePathParslet',\n    accept: type => (allowedTypes as TokenType[]).includes(type),\n    parsePrefix: parser => {\n      const type = parser.lexer.current.type as SpecialNamePathType\n      parser.consume(type)\n\n      if (!parser.consume(':')) {\n        return {\n          type: 'JsdocTypeName',\n          value: type\n        }\n      }\n\n      let result: SpecialNamePath\n\n      let token = parser.lexer.current\n      if (parser.consume('StringValue')) {\n        result = {\n          type: 'JsdocTypeSpecialNamePath',\n          value: token.text.slice(1, -1),\n          specialType: type,\n          meta: {\n            quote: token.text.startsWith('\\'') ? 'single' : 'double'\n          }\n        }\n      } else {\n        let value = ''\n        const allowed: TokenType[] = ['Identifier', '@', '/']\n        while (allowed.some(type => parser.consume(type))) {\n          value += token.text\n          token = parser.lexer.current\n        }\n        result = {\n          type: 'JsdocTypeSpecialNamePath',\n          value,\n          specialType: type,\n          meta: {\n            quote: undefined\n          }\n        }\n      }\n\n      const moduleParser = new Parser(pathGrammar, parser.lexer, parser)\n      const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL)\n      parser.acceptLexerState(moduleParser)\n\n      return assertRootResult(moduleResult)\n    }\n  })\n}\n","import type { Grammar } from './Grammar'\nimport { createNamePathParslet } from '../parslets/NamePathParslet'\nimport { createNameParslet } from '../parslets/NameParslet'\nimport { stringValueParslet } from '../parslets/StringValueParslet'\nimport { numberParslet } from '../parslets/NumberParslet'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet'\n\nconst basePathGrammar: Grammar = [\n  createNameParslet({\n    allowedAdditionalTokens: ['external', 'module']\n  }),\n  stringValueParslet,\n  numberParslet,\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar: null\n  })\n]\n\nexport const pathGrammar: Grammar = [\n  ...basePathGrammar,\n  createSpecialNamePathParslet({\n    allowedTypes: ['event'],\n    pathGrammar: basePathGrammar\n  })\n]\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport type { FunctionResult, RootResult } from '../result/RootResult'\nimport type { IntermediateResult } from '../result/IntermediateResult'\nimport type { KeyValueResult, NonRootResult } from '../result/NonRootResult'\nimport { UnexpectedTypeError } from '../errors'\nimport { assertPlainKeyValueOrRootResult } from '../assertTypes'\n\nexport function getParameters (value: IntermediateResult): Array<RootResult | KeyValueResult> {\n  let parameters: NonRootResult[] = []\n  if (value.type === 'JsdocTypeParameterList') {\n    parameters = value.elements\n  } else if (value.type === 'JsdocTypeParenthesis') {\n    parameters = [value.element]\n  } else {\n    throw new UnexpectedTypeError(value)\n  }\n\n  return parameters.map(p => assertPlainKeyValueOrRootResult(p))\n}\n\nexport function getUnnamedParameters (value: IntermediateResult): RootResult[] {\n  const parameters = getParameters(value)\n  if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n    throw new Error('No parameter should be named')\n  }\n  return parameters as RootResult[]\n}\n\nexport function createFunctionParslet ({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }: {\n  allowNamedParameters?: string[]\n  allowWithoutParenthesis: boolean\n  allowNoReturnType: boolean\n  allowNewAsFunctionKeyword: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'functionParslet',\n    accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n    parsePrefix: parser => {\n      const newKeyword = parser.consume('new')\n      parser.consume('function')\n\n      const hasParenthesis = parser.lexer.current.type === '('\n\n      if (!hasParenthesis) {\n        if (!allowWithoutParenthesis) {\n          throw new Error('function is missing parameter list')\n        }\n\n        return {\n          type: 'JsdocTypeName',\n          value: 'function'\n        }\n      }\n\n      let result: FunctionResult = {\n        type: 'JsdocTypeFunction',\n        parameters: [],\n        arrow: false,\n        constructor: newKeyword,\n        parenthesis: hasParenthesis\n      }\n\n      const value = parser.parseIntermediateType(Precedence.FUNCTION)\n\n      if (allowNamedParameters === undefined) {\n        result.parameters = getUnnamedParameters(value)\n      } else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n        result = value\n        result.constructor = true\n        return result\n      } else {\n        result.parameters = getParameters(value)\n        for (const p of result.parameters) {\n          if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`)\n          }\n        }\n      }\n\n      if (parser.consume(':')) {\n        result.returnType = parser.parseType(Precedence.PREFIX)\n      } else {\n        if (!allowNoReturnType) {\n          throw new Error('function is missing return type')\n        }\n      }\n\n      return result\n    }\n  })\n}\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\nimport { NoParsletFoundError } from '../errors'\n\nexport function createVariadicParslet ({ allowPostfix, allowEnclosingBrackets }: {\n  allowPostfix: boolean\n  allowEnclosingBrackets: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'variadicParslet',\n    accept: type => type === '...',\n    precedence: Precedence.PREFIX,\n    parsePrefix: parser => {\n      parser.consume('...')\n\n      const brackets = allowEnclosingBrackets && parser.consume('[')\n\n      try {\n        const element = parser.parseType(Precedence.PREFIX)\n        if (brackets && !parser.consume(']')) {\n          throw new Error('Unterminated variadic type. Missing \\']\\'')\n        }\n\n        return {\n          type: 'JsdocTypeVariadic',\n          element: assertRootResult(element),\n          meta: {\n            position: 'prefix',\n            squareBrackets: brackets\n          }\n        }\n      } catch (e) {\n        if (e instanceof NoParsletFoundError) {\n          if (brackets) {\n            throw new Error('Empty square brackets for variadic are not allowed.')\n          }\n          return {\n            type: 'JsdocTypeVariadic',\n            meta: {\n              position: undefined,\n              squareBrackets: false\n            }\n          }\n        } else {\n          throw e\n        }\n      }\n    },\n    parseInfix: allowPostfix\n      ? (parser, left) => {\n          parser.consume('...')\n          return {\n            type: 'JsdocTypeVariadic',\n            element: assertRootResult(left),\n            meta: {\n              position: 'suffix',\n              squareBrackets: false\n            }\n          }\n        }\n      : undefined\n  })\n}\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertNumberOrVariadicNameResult } from '../assertTypes'\nimport type { SymbolResult } from '../result/RootResult'\n\nexport const symbolParslet = composeParslet({\n  name: 'symbolParslet',\n  accept: type => type === '(',\n  precedence: Precedence.SYMBOL,\n  parseInfix: (parser, left) => {\n    if (left.type !== 'JsdocTypeName') {\n      throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')')\n    }\n    parser.consume('(')\n    const result: SymbolResult = {\n      type: 'JsdocTypeSymbol',\n      value: left.value\n    }\n    if (!parser.consume(')')) {\n      const next = parser.parseIntermediateType(Precedence.SYMBOL)\n      result.element = assertNumberOrVariadicNameResult(next)\n      if (!parser.consume(')')) {\n        throw new Error('Symbol does not end after value')\n      }\n    }\n\n    return result\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const arrayBracketsParslet = composeParslet({\n  name: 'arrayBracketsParslet',\n  precedence: Precedence.ARRAY_BRACKETS,\n  accept: (type, next) => type === '[' && next === ']',\n  parseInfix: (parser, left) => {\n    parser.consume('[')\n    parser.consume(']')\n    return {\n      type: 'JsdocTypeGeneric',\n      left: {\n        type: 'JsdocTypeName',\n        value: 'Array'\n      },\n      elements: [\n        assertRootResult(left)\n      ],\n      meta: {\n        brackets: 'square',\n        dot: false\n      }\n    }\n  }\n})\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport { Parser } from '../Parser'\nimport { Precedence } from '../Precedence'\nimport { UnexpectedTypeError } from '../errors'\nimport type { ObjectResult } from '../result/RootResult'\nimport type { Grammar } from '../grammars/Grammar'\n\nexport function createObjectParslet ({ objectFieldGrammar, allowKeyTypes }: {\n  objectFieldGrammar: Grammar\n  allowKeyTypes: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'objectParslet',\n    accept: type => type === '{',\n    parsePrefix: parser => {\n      parser.consume('{')\n      const result: ObjectResult = {\n        type: 'JsdocTypeObject',\n        meta: {\n          separator: 'comma'\n        },\n        elements: []\n      }\n\n      if (!parser.consume('}')) {\n        let separator: 'comma' | 'semicolon' | 'linebreak' | undefined\n\n        const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser)\n\n        while (true) {\n          fieldParser.acceptLexerState(parser)\n          let field = fieldParser.parseIntermediateType(Precedence.OBJECT)\n          parser.acceptLexerState(fieldParser)\n\n          if (field === undefined && allowKeyTypes) {\n            field = parser.parseIntermediateType(Precedence.OBJECT)\n          }\n\n          let optional = false\n          if (field.type === 'JsdocTypeNullable') {\n            optional = true\n            field = field.element\n          }\n\n          if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n            let quote\n            if (field.type === 'JsdocTypeStringValue') {\n              quote = field.meta.quote\n            }\n\n            result.elements.push({\n              type: 'JsdocTypeObjectField',\n              key: field.value.toString(),\n              right: undefined,\n              optional,\n              readonly: false,\n              meta: {\n                quote\n              }\n            })\n          } else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n            result.elements.push(field)\n          } else {\n            throw new UnexpectedTypeError(field)\n          }\n          if (parser.lexer.current.startOfLine) {\n            separator = 'linebreak'\n            // Handle single stray comma/semi-colon\n            parser.consume(',') || parser.consume(';')\n          } else if (parser.consume(',')) {\n            separator = 'comma'\n          } else if (parser.consume(';')) {\n            separator = 'semicolon'\n          } else {\n            break\n          }\n          const type = parser.lexer.current.type\n          if (type === '}') {\n            break\n          }\n        }\n\n        result.meta.separator = separator ?? 'comma' // TODO: use undefined here\n        if (separator === 'linebreak') {\n          // TODO: Consume appropriate whitespace\n          result.meta.propertyIndent = '  '\n        }\n\n        if (!parser.consume('}')) {\n          throw new Error('Unterminated record type. Missing \\'}\\'')\n        }\n      }\n      return result\n    }\n  })\n}\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { UnexpectedTypeError } from '../errors'\nimport { assertRootResult, isSquaredProperty } from '../assertTypes'\n\nexport function createObjectFieldParslet ({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }: {\n  allowSquaredProperties: boolean\n  allowKeyTypes: boolean\n  allowOptional: boolean\n  allowReadonly: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'objectFieldParslet',\n    precedence: Precedence.KEY_VALUE,\n    accept: type => type === ':',\n    parseInfix: (parser, left) => {\n      let optional = false\n      let readonlyProperty = false\n\n      if (allowOptional && left.type === 'JsdocTypeNullable') {\n        optional = true\n        left = left.element\n      }\n\n      if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n        readonlyProperty = true\n        left = left.element\n      }\n\n      // object parslet uses a special grammar and for the value we want to switch back to the parent\n      const parentParser = parser.baseParser ?? parser\n      parentParser.acceptLexerState(parser)\n\n      if (\n        left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n        isSquaredProperty(left)\n      ) {\n        /* c8 ignore next 3 -- Guard */\n        if (isSquaredProperty(left) && !allowSquaredProperties) {\n          throw new UnexpectedTypeError(left)\n        }\n\n        parentParser.consume(':')\n\n        let quote\n        if (left.type === 'JsdocTypeStringValue') {\n          quote = left.meta.quote\n        }\n\n        const right = parentParser.parseType(Precedence.KEY_VALUE)\n        parser.acceptLexerState(parentParser)\n\n        return {\n          type: 'JsdocTypeObjectField',\n          key: isSquaredProperty(left) ? left : left.value.toString(),\n          right,\n          optional,\n          readonly: readonlyProperty,\n          meta: {\n            quote\n          }\n        }\n      } else {\n        if (!allowKeyTypes) {\n          throw new UnexpectedTypeError(left)\n        }\n\n        parentParser.consume(':')\n\n        const right = parentParser.parseType(Precedence.KEY_VALUE)\n        parser.acceptLexerState(parentParser)\n\n        return {\n          type: 'JsdocTypeJsdocObjectField',\n          left: assertRootResult(left),\n          right\n        }\n      }\n    }\n  })\n}\n","import { composeParslet, type ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { UnexpectedTypeError } from '../errors'\n\nexport function createKeyValueParslet ({ allowOptional, allowVariadic }: {\n  allowOptional: boolean\n  allowVariadic: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'keyValueParslet',\n    precedence: Precedence.KEY_VALUE,\n    accept: type => type === ':',\n    parseInfix: (parser, left) => {\n      let optional = false\n      let variadic = false\n\n      if (allowOptional && left.type === 'JsdocTypeNullable') {\n        optional = true\n        left = left.element\n      }\n\n      if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n        variadic = true\n        left = left.element\n      }\n\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left)\n      }\n\n      parser.consume(':')\n\n      const right = parser.parseType(Precedence.KEY_VALUE)\n\n      return {\n        type: 'JsdocTypeKeyValue',\n        key: left.value,\n        right,\n        optional,\n        variadic\n      }\n    }\n  })\n}\n","import { baseGrammar } from './baseGrammar'\nimport type { Grammar } from './Grammar'\nimport { pathGrammar } from './pathGrammar'\nimport { createFunctionParslet } from '../parslets/FunctionParslet'\nimport { stringValueParslet } from '../parslets/StringValueParslet'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet'\nimport { createVariadicParslet } from '../parslets/VariadicParslet'\nimport { createNameParslet } from '../parslets/NameParslet'\nimport { symbolParslet } from '../parslets/SymbolParslet'\nimport { arrayBracketsParslet } from '../parslets/ArrayBracketsParslet'\nimport { createNamePathParslet } from '../parslets/NamePathParslet'\nimport { createObjectParslet } from '../parslets/ObjectParslet'\nimport { createObjectFieldParslet } from '../parslets/ObjectFieldParslet'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet'\n\nconst jsdocBaseGrammar = [\n  ...baseGrammar,\n  createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }),\n  stringValueParslet,\n  createSpecialNamePathParslet({\n    allowedTypes: ['module', 'external', 'event'],\n    pathGrammar\n  }),\n  createVariadicParslet({\n    allowEnclosingBrackets: true,\n    allowPostfix: true\n  }),\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }),\n  symbolParslet,\n  arrayBracketsParslet,\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })\n]\n\nexport const jsdocGrammar: Grammar = [\n  ...jsdocBaseGrammar,\n  createObjectParslet({\n    // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n    // we leave out the object type deliberately\n    objectFieldGrammar: [\n      createNameParslet({\n        allowedAdditionalTokens: ['typeof', 'module', 'in']\n      }),\n      createObjectFieldParslet({\n        allowSquaredProperties: false,\n        allowKeyTypes: true,\n        allowOptional: false,\n        allowReadonly: false\n      }),\n      ...jsdocBaseGrammar\n    ],\n    allowKeyTypes: true\n  }),\n  createKeyValueParslet({\n    allowOptional: true,\n    allowVariadic: true\n  })\n]\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\n\nexport const typeOfParslet = composeParslet({\n  name: 'typeOfParslet',\n  accept: type => type === 'typeof',\n  parsePrefix: parser => {\n    parser.consume('typeof')\n    return {\n      type: 'JsdocTypeTypeof',\n      element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n    }\n  }\n})\n","import { baseGrammar } from './baseGrammar'\nimport { pathGrammar } from './pathGrammar'\nimport { createNameParslet } from '../parslets/NameParslet'\nimport { nullableParslet } from '../parslets/NullableParslets'\nimport type { Grammar } from './Grammar'\nimport { optionalParslet } from '../parslets/OptionalParslet'\nimport { stringValueParslet } from '../parslets/StringValueParslet'\nimport { numberParslet } from '../parslets/NumberParslet'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet'\nimport { createObjectParslet } from '../parslets/ObjectParslet'\nimport { typeOfParslet } from '../parslets/TypeOfParslet'\nimport { createFunctionParslet } from '../parslets/FunctionParslet'\nimport { createVariadicParslet } from '../parslets/VariadicParslet'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet'\nimport { createNamePathParslet } from '../parslets/NamePathParslet'\nimport { symbolParslet } from '../parslets/SymbolParslet'\nimport { createObjectFieldParslet } from '../parslets/ObjectFieldParslet'\n\nconst objectFieldGrammar: Grammar = [\n  createNameParslet({\n    allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n  }),\n  nullableParslet,\n  optionalParslet,\n  stringValueParslet,\n  numberParslet,\n  createObjectFieldParslet({\n    allowSquaredProperties: false,\n    allowKeyTypes: false,\n    allowOptional: false,\n    allowReadonly: false\n  })\n]\n\nexport const closureGrammar = [\n  ...baseGrammar,\n  createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar\n  }),\n  createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }),\n  typeOfParslet,\n  createFunctionParslet({\n    allowWithoutParenthesis: false,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }),\n  createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  // additional name parslet is needed for some special cases\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }),\n  createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }),\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  }),\n  createKeyValueParslet({\n    allowOptional: false,\n    allowVariadic: false\n  }),\n  symbolParslet\n]\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { UnexpectedTypeError } from '../errors'\nimport { assertRootResult } from '../assertTypes'\n\nexport const assertsParslet = composeParslet({\n  name: 'assertsParslet',\n  accept: type => type === 'asserts',\n  parsePrefix: (parser) => {\n    parser.consume('asserts')\n\n    const left = parser.parseIntermediateType(Precedence.SYMBOL)\n\n    if (left.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name.')\n    }\n\n    if (!parser.consume('is')) {\n      return {\n        type: 'JsdocTypeAssertsPlain',\n        element: left\n      }\n    }\n\n    return {\n      type: 'JsdocTypeAsserts',\n      left,\n      right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n    }\n  }\n})\n","import { assertPlainKeyValueResult, assertRootResult } from '../assertTypes'\nimport { composeParslet, type ParsletFunction } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport type { TupleResult } from '../result/RootResult'\nimport type { IntermediateResult } from '../result/IntermediateResult'\n\nexport function createTupleParslet ({ allowQuestionMark }: {\n  allowQuestionMark: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'tupleParslet',\n    accept: type => type === '[',\n    parsePrefix: parser => {\n      parser.consume('[')\n      const result: TupleResult = {\n        type: 'JsdocTypeTuple',\n        elements: []\n      }\n\n      if (parser.consume(']')) {\n        return result\n      }\n\n      const typeList = parser.parseIntermediateType(Precedence.ALL)\n      if (typeList.type === 'JsdocTypeParameterList') {\n        if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n          result.elements = typeList.elements.map(assertPlainKeyValueResult)\n        } else {\n          result.elements = typeList.elements.map(assertRootResult)\n        }\n      } else {\n        if (typeList.type === 'JsdocTypeKeyValue') {\n          result.elements = [assertPlainKeyValueResult(typeList)]\n        } else {\n          result.elements = [assertRootResult(typeList)]\n        }\n      }\n\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated \\'[\\'')\n      }\n\n      if (!allowQuestionMark && result.elements.some((e: IntermediateResult) => e.type === 'JsdocTypeUnknown')) {\n        throw new Error('Question mark in tuple not allowed')\n      }\n\n      return result\n    }\n  })\n}\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const keyOfParslet = composeParslet({\n  name: 'keyOfParslet',\n  accept: type => type === 'keyof',\n  parsePrefix: parser => {\n    parser.consume('keyof')\n    return {\n      type: 'JsdocTypeKeyof',\n      element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\n\nexport const importParslet = composeParslet({\n  name: 'importParslet',\n  accept: type => type === 'import',\n  parsePrefix: parser => {\n    parser.consume('import')\n    if (!parser.consume('(')) {\n      throw new Error('Missing parenthesis after import keyword')\n    }\n    const path = parser.parseType(Precedence.PREFIX)\n    if (path.type !== 'JsdocTypeStringValue') {\n      throw new Error('Only string values are allowed as paths for imports')\n    }\n    if (!parser.consume(')')) {\n      throw new Error('Missing closing parenthesis after import keyword')\n    }\n    return {\n      type: 'JsdocTypeImport',\n      element: path\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\n\nexport const readonlyPropertyParslet = composeParslet({\n  name: 'readonlyPropertyParslet',\n  accept: type => type === 'readonly',\n  parsePrefix: parser => {\n    parser.consume('readonly')\n    return {\n      type: 'JsdocTypeReadonlyProperty',\n      element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertPlainKeyValueOrNameResult } from '../assertTypes'\nimport { getParameters } from './FunctionParslet'\n\nexport const arrowFunctionParslet = composeParslet({\n  name: 'arrowFunctionParslet',\n  precedence: Precedence.ARROW,\n  accept: type => type === '=>',\n  parseInfix: (parser, left) => {\n    parser.consume('=>')\n    return {\n      type: 'JsdocTypeFunction',\n      parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n      arrow: true,\n      constructor: false,\n      parenthesis: true,\n      returnType: parser.parseType(Precedence.OBJECT)\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { UnexpectedTypeError } from '../errors'\nimport type { FunctionResult } from '../result/RootResult'\nimport type { TypeParameterResult } from '../result/NonRootResult'\n\nexport const genericArrowFunctionParslet = composeParslet({\n  name: 'genericArrowFunctionParslet',\n  accept: type => type === '<',\n  parsePrefix: (parser) => {\n    const typeParameters: TypeParameterResult[] = []\n    parser.consume('<')\n\n    do {\n      let defaultValue = undefined\n      let name = parser.parseIntermediateType(Precedence.SYMBOL)\n      if (name.type === 'JsdocTypeOptional') {\n        name = name.element\n        defaultValue = parser.parseType(Precedence.SYMBOL)\n      }\n      if (name.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(name)\n      }\n      let constraint = undefined\n      if (parser.consume('extends')) {\n        constraint = parser.parseType(Precedence.SYMBOL)\n        // Got an equal sign\n        if (constraint.type === 'JsdocTypeOptional') {\n          constraint = constraint.element\n          defaultValue = parser.parseType(Precedence.SYMBOL)\n        }\n      }\n\n      const typeParameter: TypeParameterResult = {\n        type: 'JsdocTypeTypeParameter',\n        name\n      }\n\n      if (constraint !== undefined) {\n        typeParameter.constraint = constraint\n      }\n\n      if (defaultValue !== undefined) {\n        typeParameter.defaultValue = defaultValue\n      }\n\n      typeParameters.push(typeParameter)\n\n      if (parser.consume('>')) {\n        break\n      }\n    } while (parser.consume(','))\n\n    const functionBase = parser.parseIntermediateType(Precedence.SYMBOL) as FunctionResult\n    functionBase.typeParameters = typeParameters\n\n    return functionBase\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertRootResult } from '../assertTypes'\n\nexport const intersectionParslet = composeParslet({\n  name: 'intersectionParslet',\n  accept: type => type === '&',\n  precedence: Precedence.INTERSECTION,\n  parseInfix: (parser, left) => {\n    parser.consume('&')\n\n    const elements = []\n    do {\n      elements.push(parser.parseType(Precedence.INTERSECTION))\n    } while (parser.consume('&'))\n\n    return {\n      type: 'JsdocTypeIntersection',\n      elements: [assertRootResult(left), ...elements]\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { UnexpectedTypeError } from '../errors'\nimport { assertRootResult } from '../assertTypes'\n\nexport const predicateParslet = composeParslet({\n  name: 'predicateParslet',\n  precedence: Precedence.INFIX,\n  accept: type => type === 'is',\n  parseInfix: (parser, left) => {\n    if (left.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.')\n    }\n\n    parser.consume('is')\n\n    return {\n      type: 'JsdocTypePredicate',\n      left,\n      right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport type { IndexSignatureResult, MappedTypeResult } from '../result/NonRootResult'\nimport { Precedence } from '../Precedence'\n\nexport const objectSquaredPropertyParslet = composeParslet({\n  name: 'objectSquareBracketPropertyParslet',\n  accept: type => type === '[',\n  parsePrefix: parser => {\n    if (parser.baseParser === undefined) {\n      throw new Error('Only allowed inside object grammar')\n    }\n    parser.consume('[')\n    const key = parser.lexer.current.text\n    parser.consume('Identifier')\n    let result: IndexSignatureResult | MappedTypeResult\n\n    if (parser.consume(':')) {\n      const parentParser = parser.baseParser\n      parentParser.acceptLexerState(parser)\n\n      result = {\n        type: 'JsdocTypeIndexSignature',\n        key,\n        right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n      }\n\n      parser.acceptLexerState(parentParser)\n    } else if (parser.consume('in')) {\n      const parentParser = parser.baseParser\n      parentParser.acceptLexerState(parser)\n\n      result = {\n        type: 'JsdocTypeMappedType',\n        key,\n        right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n      }\n\n      parser.acceptLexerState(parentParser)\n    } else {\n      throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.')\n    }\n\n    if (!parser.consume(']')) {\n      throw new Error('Unterminated square brackets')\n    }\n\n    return result\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\nimport { assertArrayOrTupleResult } from '../assertTypes'\n\nexport const readonlyArrayParslet = composeParslet({\n  name: 'readonlyArrayParslet',\n  accept: type => type === 'readonly',\n  parsePrefix: parser => {\n    parser.consume('readonly')\n    return {\n      type: 'JsdocTypeReadonlyArray',\n      element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n    }\n  }\n})\n","import { composeParslet } from './Parslet'\nimport { Precedence } from '../Precedence'\n// import { UnexpectedTypeError } from '../errors'\nimport { assertRootResult } from '../assertTypes'\nimport type { RootResult, NullableResult } from '../result/RootResult'\n\nexport const conditionalParslet = composeParslet({\n  name: 'conditionalParslet',\n  precedence: Precedence.INFIX,\n  accept: type => type === 'extends',\n  parseInfix: (parser, left) => {\n    parser.consume('extends')\n\n    const extendsType = (\n      parser.parseType(Precedence.KEY_OF_TYPE_OF\n      ) as NullableResult<RootResult>).element\n\n    // parser.consume('?')\n\n    const trueType = parser.parseType(Precedence.INFIX)\n\n    parser.consume(':')\n\n    return {\n      type: 'JsdocTypeConditional',\n      checksType: assertRootResult(left),\n      extendsType,\n      trueType,\n      falseType: parser.parseType(Precedence.INFIX)\n    }\n  }\n})\n","import { assertsParslet } from '../parslets/assertsParslet'\nimport { baseGrammar } from './baseGrammar'\nimport type { Grammar } from './Grammar'\nimport { pathGrammar } from './pathGrammar'\nimport { createNameParslet } from '../parslets/NameParslet'\nimport { nullableParslet } from '../parslets/NullableParslets'\nimport { optionalParslet } from '../parslets/OptionalParslet'\nimport { stringValueParslet } from '../parslets/StringValueParslet'\nimport { numberParslet } from '../parslets/NumberParslet'\nimport { createFunctionParslet } from '../parslets/FunctionParslet'\nimport { createObjectParslet } from '../parslets/ObjectParslet'\nimport { createTupleParslet } from '../parslets/TupleParslet'\nimport { createVariadicParslet } from '../parslets/VariadicParslet'\nimport { typeOfParslet } from '../parslets/TypeOfParslet'\nimport { keyOfParslet } from '../parslets/KeyOfParslet'\nimport { importParslet } from '../parslets/ImportParslet'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet'\nimport { readonlyPropertyParslet } from '../parslets/ReadonlyPropertyParslet'\nimport { arrayBracketsParslet } from '../parslets/ArrayBracketsParslet'\nimport { arrowFunctionParslet } from '../parslets/ArrowFunctionParslet'\nimport { genericArrowFunctionParslet } from '../parslets/GenericArrowFunctionParslet'\nimport { createNamePathParslet } from '../parslets/NamePathParslet'\nimport { intersectionParslet } from '../parslets/IntersectionParslet'\nimport { predicateParslet } from '../parslets/predicateParslet'\nimport { createObjectFieldParslet } from '../parslets/ObjectFieldParslet'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet'\nimport { objectSquaredPropertyParslet } from '../parslets/ObjectSquaredPropertyParslet'\nimport { readonlyArrayParslet } from '../parslets/ReadonlyArrayParslet'\nimport { conditionalParslet } from '../parslets/ConditionalParslet'\n\nconst objectFieldGrammar: Grammar = [\n  readonlyPropertyParslet,\n  createNameParslet({\n    allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n  }),\n  nullableParslet,\n  optionalParslet,\n  stringValueParslet,\n  numberParslet,\n  createObjectFieldParslet({\n    allowSquaredProperties: true,\n    allowKeyTypes: false,\n    allowOptional: true,\n    allowReadonly: true\n  }),\n  objectSquaredPropertyParslet\n]\n\nexport const typescriptGrammar: Grammar = [\n  ...baseGrammar,\n  createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar\n  }),\n  readonlyArrayParslet,\n  typeOfParslet,\n  keyOfParslet,\n  importParslet,\n  stringValueParslet,\n  createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNoReturnType: true,\n    allowNamedParameters: ['this', 'new', 'args'],\n    allowNewAsFunctionKeyword: true\n  }),\n  createTupleParslet({\n    allowQuestionMark: false\n  }),\n  createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  assertsParslet,\n  conditionalParslet,\n  createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }),\n  createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }),\n  arrayBracketsParslet,\n  arrowFunctionParslet,\n  genericArrowFunctionParslet,\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: true,\n    allowJsdocNamePaths: false,\n    pathGrammar\n  }),\n  intersectionParslet,\n  predicateParslet,\n  createKeyValueParslet({\n    allowVariadic: true,\n    allowOptional: true\n  })\n]\n","import { Parser } from './Parser'\nimport { jsdocGrammar } from './grammars/jsdocGrammar'\nimport { closureGrammar } from './grammars/closureGrammar'\nimport { typescriptGrammar } from './grammars/typescriptGrammar'\nimport type { RootResult } from './result/RootResult'\n\nexport type ParseMode = 'closure' | 'jsdoc' | 'typescript'\n\n/**\n * This function parses the given expression in the given mode and produces a {@link RootResult}.\n * @param expression\n * @param mode\n */\nexport function parse (expression: string, mode: ParseMode): RootResult {\n  switch (mode) {\n    case 'closure':\n      return (new Parser(closureGrammar, expression)).parse()\n    case 'jsdoc':\n      return (new Parser(jsdocGrammar, expression)).parse()\n    case 'typescript':\n      return (new Parser(typescriptGrammar, expression)).parse()\n  }\n}\n\n/**\n * This function tries to parse the given expression in multiple modes and returns the first successful\n * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n * no mode was successful it throws the error that was produced by the last parsing attempt.\n * @param expression\n * @param modes\n */\nexport function tryParse (expression: string, modes: ParseMode[] = ['typescript', 'closure', 'jsdoc']): RootResult {\n  let error\n  for (const mode of modes) {\n    try {\n      return parse(expression, mode)\n    } catch (e) {\n      error = e\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/only-throw-error -- Ok\n  throw error\n}\n","import type { KeyValueResult, NonRootResult } from '../result/NonRootResult'\nimport type { FunctionResult, RootResult } from '../result/RootResult'\n\nexport type TransformFunction<TransformResult> = (parseResult: NonRootResult) => TransformResult\n\nexport type TransformRule<TransformResult, InputType extends NonRootResult> = (parseResult: InputType, transform: TransformFunction<TransformResult>) => TransformResult\n\nexport type TransformRules<TransformResult> = {\n  [P in NonRootResult as P['type']]: TransformRule<TransformResult, P>\n}\n\nexport function transform<TransformResult> (rules: TransformRules<TransformResult>, parseResult: NonRootResult): TransformResult {\n  const rule = rules[parseResult.type] as TransformRule<TransformResult, NonRootResult>\n  if (rule === undefined) {\n    throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`)\n  }\n\n  return rule(parseResult, aParseResult => transform(rules, aParseResult))\n}\n\nexport function notAvailableTransform<TransformResult> (parseResult: NonRootResult): TransformResult {\n  throw new Error('This transform is not available. Are you trying the correct parsing mode?')\n}\n\ninterface SpecialFunctionParams {\n  params: Array<RootResult | KeyValueResult>\n  this?: RootResult\n  new?: RootResult\n}\n\nexport function extractSpecialParams (source: FunctionResult): SpecialFunctionParams {\n  const result: SpecialFunctionParams = {\n    params: []\n  }\n\n  for (const param of source.parameters) {\n    if (param.type === 'JsdocTypeKeyValue') {\n      if (param.key === 'this') {\n        result.this = param.right\n      } else if (param.key === 'new') {\n        result.new = param.right\n      } else {\n        result.params.push(param)\n      }\n    } else {\n      result.params.push(param)\n    }\n  }\n\n  return result\n}\n","import { transform, type TransformRules } from './transform'\nimport type { NonRootResult } from '../result/NonRootResult'\nimport type { RootResult } from '../result/RootResult'\n\nfunction applyPosition (position: 'prefix' | 'suffix', target: string, value: string): string {\n  return position === 'prefix' ? value + target : target + value\n}\n\nexport function quote (value: string, quote: 'single' | 'double' | undefined): string {\n  switch (quote) {\n    case 'double':\n      return `\"${value}\"`\n    case 'single':\n      return `'${value}'`\n    case undefined:\n      return value\n  }\n}\n\nexport function stringifyRules (): TransformRules<string> {\n  return {\n    JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n\n    JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n\n    JsdocTypeFunction: (result, transform) => {\n      if (!result.arrow) {\n        let stringified = result.constructor ? 'new' : 'function'\n        if (!result.parenthesis) {\n          return stringified\n        }\n        stringified += `(${result.parameters.map(transform).join(', ')})`\n        if (result.returnType !== undefined) {\n          stringified += `: ${transform(result.returnType)}`\n        }\n        return stringified\n      } else {\n        if (result.returnType === undefined) {\n          throw new Error('Arrow function needs a return type.')\n        }\n        let stringified = `${\n          result.typeParameters !== undefined\n            ? `<${result.typeParameters.map(transform).join(', ') ?? ''}>`\n            : ''\n        }(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`\n        if (result.constructor) {\n          stringified = 'new ' + stringified\n        }\n        return stringified\n      }\n    },\n\n    JsdocTypeName: result => result.value,\n\n    JsdocTypeTuple: (result, transform) => `[${(result.elements as NonRootResult[]).map(transform).join(', ')}]`,\n\n    JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n      ? '...'\n      : applyPosition(result.meta.position, transform(result.element as NonRootResult), '...'),\n\n    JsdocTypeNamePath: (result, transform) => {\n      const left = transform(result.left)\n      const right = transform(result.right)\n      switch (result.pathType) {\n        case 'inner':\n          return `${left}~${right}`\n        case 'instance':\n          return `${left}#${right}`\n        case 'property':\n          return `${left}.${right}`\n        case 'property-brackets':\n          return `${left}[${right}]`\n      }\n    },\n\n    JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n\n    JsdocTypeAny: () => '*',\n\n    JsdocTypeGeneric: (result, transform) => {\n      if (result.meta.brackets === 'square') {\n        const element = result.elements[0]\n        const transformed = transform(element)\n        if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n          return `(${transformed})[]`\n        } else {\n          return `${transformed}[]`\n        }\n      } else {\n        return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.infer === true ? 'infer ' : ''}${result.elements.map(transform).join(', ')}>`\n      }\n    },\n\n    JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n\n    JsdocTypeObjectField: (result, transform) => {\n      let text = ''\n      if (result.readonly) {\n        text += 'readonly '\n      }\n      if (typeof result.key === 'string') {\n        text += quote(result.key, result.meta.quote)\n      } else {\n        text += transform(result.key)\n      }\n\n      if (result.optional) {\n        text += '?'\n      }\n\n      if (result.right === undefined) {\n        return text\n      } else {\n        return text + `: ${transform(result.right)}`\n      }\n    },\n\n    JsdocTypeJsdocObjectField: (result, transform) => `${transform(result.left)}: ${transform(result.right)}`,\n\n    JsdocTypeKeyValue: (result, transform) => {\n      let text = result.key\n      if (result.optional) {\n        text += '?'\n      }\n      if (result.variadic) {\n        text = '...' + text\n      }\n\n      if (result.right === undefined) {\n        return text\n      } else {\n        return text + `: ${transform(result.right)}`\n      }\n    },\n\n    JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n\n    JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n\n    JsdocTypeNull: () => 'null',\n\n    JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n\n    JsdocTypeNumber: result => result.value.toString(),\n\n    JsdocTypeObject: (result, transform) => `{${\n      (result.meta.separator === 'linebreak' && result.elements.length > 1\n       ? '\\n' + (result.meta.propertyIndent ?? '')\n       : '') +\n      result.elements.map(transform).join(\n        (result.meta.separator === 'comma' ? ', ' : result.meta.separator === 'linebreak' ? '\\n' + (result.meta.propertyIndent ?? '') : '; ')\n      ) +\n      (result.meta.separator === 'linebreak' && result.elements.length > 1\n       ? '\\n'\n       : '')\n    }}`,\n\n    JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n\n    JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n\n    JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n\n    JsdocTypeUndefined: () => 'undefined',\n\n    JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n\n    JsdocTypeUnknown: () => '?',\n\n    JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n\n    JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n\n    JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n\n    JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n\n    JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n\n    JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`,\n\n    JsdocTypeReadonlyArray: (result, transform) => `readonly ${transform(result.element)}`,\n\n    JsdocTypeAssertsPlain: (result, transform) => `asserts ${transform(result.element)}`,\n\n    JsdocTypeConditional: (result, transform) => `${transform(result.checksType)} extends ${transform(result.extendsType)} ? ${transform(result.trueType)} : ${transform(result.falseType)}`,\n\n    JsdocTypeTypeParameter: (result, transform) => `${\n      transform(result.name)}${\n        result.constraint !== undefined ? ` extends ${transform(result.constraint)}` : ''\n      }${\n        result.defaultValue !== undefined ? ` = ${transform(result.defaultValue)}` : ''\n      }`\n  }\n}\n\nconst storedStringifyRules = stringifyRules()\n\nexport function stringify (result: RootResult): string {\n  return transform(storedStringifyRules, result)\n}\n","import { extractSpecialParams, notAvailableTransform, transform, type TransformRules } from './transform'\nimport { assertRootResult } from '../assertTypes'\nimport type { RootResult } from '../result/RootResult'\nimport { quote } from './stringify'\n\nexport const reservedWords = [\n  'null',\n  'true',\n  'false',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield'\n]\n\ninterface ModifiableResult {\n  optional?: boolean\n  nullable?: boolean\n  repeatable?: boolean\n}\n\nexport type CatharsisParseResult =\n  CatharsisNameResult\n  | CatharsisUnionResult\n  | CatharsisGenericResult\n  | CatharsisNullResult\n  | CatharsisUndefinedResult\n  | CatharsisAllResult\n  | CatharsisUnknownResult\n  | CatharsisFunctionResult\n  | CatharsisRecordResult\n  | CatharsisFieldResult\n\nexport type CatharsisNameResult = ModifiableResult & {\n  type: 'NameExpression'\n  name: string\n  reservedWord?: boolean\n}\n\nexport type CatharsisUnionResult = ModifiableResult & {\n  type: 'TypeUnion'\n  elements: CatharsisParseResult[]\n}\n\nexport type CatharsisGenericResult = ModifiableResult & {\n  type: 'TypeApplication'\n  expression: CatharsisParseResult\n  applications: CatharsisParseResult[]\n}\n\nexport type CatharsisNullResult = ModifiableResult & {\n  type: 'NullLiteral'\n}\n\nexport type CatharsisUndefinedResult = ModifiableResult & {\n  type: 'UndefinedLiteral'\n}\n\nexport type CatharsisAllResult = ModifiableResult & {\n  type: 'AllLiteral'\n}\n\nexport type CatharsisUnknownResult = ModifiableResult & {\n  type: 'UnknownLiteral'\n}\n\nexport type CatharsisFunctionResult = ModifiableResult & {\n  type: 'FunctionType'\n  params: CatharsisParseResult[]\n  result?: CatharsisParseResult\n  this?: CatharsisParseResult\n  new?: CatharsisParseResult\n}\n\nexport type CatharsisFieldResult = ModifiableResult & {\n  type: 'FieldType'\n  key: CatharsisParseResult\n  value: CatharsisParseResult | undefined\n}\n\nexport type CatharsisRecordResult = ModifiableResult & {\n  type: 'RecordType'\n  fields: CatharsisFieldResult[]\n}\n\nfunction makeName (value: string): CatharsisNameResult {\n  const result: CatharsisNameResult = {\n    type: 'NameExpression',\n    name: value\n  }\n  if (reservedWords.includes(value)) {\n    result.reservedWord = true\n  }\n  return result\n}\n\nconst catharsisTransformRules: TransformRules<CatharsisParseResult> = {\n  JsdocTypeOptional: (result, transform) => {\n    const transformed = transform(result.element)\n    transformed.optional = true\n    return transformed\n  },\n\n  JsdocTypeNullable: (result, transform) => {\n    const transformed = transform(result.element)\n    transformed.nullable = true\n    return transformed\n  },\n\n  JsdocTypeNotNullable: (result, transform) => {\n    const transformed = transform(result.element)\n    transformed.nullable = false\n    return transformed\n  },\n\n  JsdocTypeVariadic: (result, transform) => {\n    if (result.element === undefined) {\n      throw new Error('dots without value are not allowed in catharsis mode')\n    }\n    const transformed = transform(result.element)\n    transformed.repeatable = true\n    return transformed\n  },\n\n  JsdocTypeAny: () => ({\n    type: 'AllLiteral'\n  }),\n\n  JsdocTypeNull: () => ({\n    type: 'NullLiteral'\n  }),\n\n  JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n\n  JsdocTypeUndefined: () => ({\n    type: 'UndefinedLiteral'\n  }),\n\n  JsdocTypeUnknown: () => ({\n    type: 'UnknownLiteral'\n  }),\n\n  JsdocTypeFunction: (result, transform) => {\n    const params = extractSpecialParams(result)\n\n    const transformed: CatharsisFunctionResult = {\n      type: 'FunctionType',\n      params: params.params.map(transform)\n    }\n\n    if (params.this !== undefined) {\n      transformed.this = transform(params.this)\n    }\n\n    if (params.new !== undefined) {\n      transformed.new = transform(params.new)\n    }\n\n    if (result.returnType !== undefined) {\n      transformed.result = transform(result.returnType)\n    }\n\n    return transformed\n  },\n\n  JsdocTypeGeneric: (result, transform) => ({\n    type: 'TypeApplication',\n    applications: result.elements.map(o => transform(o)),\n    expression: transform(result.left)\n  }),\n\n  JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n\n  JsdocTypeName: result => {\n    if (result.value !== 'function') {\n      return makeName(result.value)\n    } else {\n      return {\n        type: 'FunctionType',\n        params: []\n      }\n    }\n  },\n\n  JsdocTypeNumber: result => makeName(result.value.toString()),\n\n  JsdocTypeObject: (result, transform) => {\n    const transformed: CatharsisRecordResult = {\n      type: 'RecordType',\n      fields: []\n    }\n    for (const field of result.elements) {\n      if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n        transformed.fields.push({\n          type: 'FieldType',\n          key: transform(field),\n          value: undefined\n        })\n      } else {\n        transformed.fields.push(transform(field) as unknown as CatharsisFieldResult)\n      }\n    }\n\n    return transformed\n  },\n\n  JsdocTypeObjectField: (result, transform) => {\n    if (typeof result.key !== 'string') {\n      throw new Error('Index signatures and mapped types are not supported')\n    }\n    return {\n      type: 'FieldType',\n      key: makeName(quote(result.key, result.meta.quote)),\n      value: result.right === undefined ? undefined : transform(result.right)\n    }\n  },\n\n  JsdocTypeJsdocObjectField: (result, transform) => ({\n    type: 'FieldType',\n    key: transform(result.left),\n    value: transform(result.right)\n  }),\n\n  JsdocTypeUnion: (result, transform) => ({\n    type: 'TypeUnion',\n    elements: result.elements.map(e => transform(e))\n  }),\n\n  JsdocTypeKeyValue: (result, transform) => ({\n    type: 'FieldType',\n    key: makeName(result.key),\n    value: result.right === undefined ? undefined : transform(result.right)\n  }),\n\n  JsdocTypeNamePath: (result, transform) => {\n    const leftResult = transform(result.left) as CatharsisNameResult\n    let rightValue\n    if (result.right.type === 'JsdocTypeSpecialNamePath') {\n      rightValue = (transform(result.right) as CatharsisNameResult).name\n    } else {\n      rightValue = quote(result.right.value, result.right.meta.quote)\n    }\n\n    const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.'\n\n    return makeName(`${leftResult.name}${joiner}${rightValue}`)\n  },\n\n  JsdocTypeSymbol: result => {\n    let value = ''\n\n    let element = result.element\n    let trailingDots = false\n\n    if (element?.type === 'JsdocTypeVariadic') {\n      if (element.meta.position === 'prefix') {\n        value = '...'\n      } else {\n        trailingDots = true\n      }\n      element = element.element\n    }\n\n    if (element?.type === 'JsdocTypeName') {\n      value += element.value\n    } else if (element?.type === 'JsdocTypeNumber') {\n      value += element.value.toString()\n    }\n\n    if (trailingDots) {\n      value += '...'\n    }\n\n    return makeName(`${result.value}(${value})`)\n  },\n\n  JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n\n  JsdocTypeMappedType: notAvailableTransform,\n  JsdocTypeIndexSignature: notAvailableTransform,\n  JsdocTypeImport: notAvailableTransform,\n  JsdocTypeKeyof: notAvailableTransform,\n  JsdocTypeTuple: notAvailableTransform,\n  JsdocTypeTypeof: notAvailableTransform,\n  JsdocTypeIntersection: notAvailableTransform,\n  JsdocTypeProperty: notAvailableTransform,\n  JsdocTypePredicate: notAvailableTransform,\n  JsdocTypeAsserts: notAvailableTransform,\n  JsdocTypeReadonlyArray: notAvailableTransform,\n  JsdocTypeAssertsPlain: notAvailableTransform,\n  JsdocTypeConditional: notAvailableTransform,\n  JsdocTypeTypeParameter: notAvailableTransform\n}\n\nexport function catharsisTransform (result: RootResult): CatharsisParseResult {\n  return transform(catharsisTransformRules, result)\n}\n","import { extractSpecialParams, notAvailableTransform, transform, type TransformRules } from './transform'\nimport type { QuoteStyle, RootResult } from '../result/RootResult'\nimport { assertRootResult } from '../assertTypes'\nimport type { NonRootResult } from '../result/NonRootResult'\n\nexport type JtpResult =\n  JtpNameResult\n  | JtpNullableResult\n  | JtpNotNullableResult\n  | JtpOptionalResult\n  | JtpVariadicResult\n  | JtpTypeOfResult\n  | JtpTupleResult\n  | JtpKeyOfResult\n  | JtpStringValueResult\n  | JtpImportResult\n  | JtpAnyResult\n  | JtpUnknownResult\n  | JtpFunctionResult\n  | JtpGenericResult\n  | JtpRecordEntryResult\n  | JtpRecordResult\n  | JtpMemberResult\n  | JtpUnionResult\n  | JtpParenthesisResult\n  | JtpNamedParameterResult\n  | JtpModuleResult\n  | JtpFilePath\n  | JtpIntersectionResult\n  | JtpNumberResult\n\ntype JtpQuoteStyle = 'single' | 'double' | 'none'\n\nexport interface JtpNullableResult {\n  type: 'NULLABLE'\n  value: JtpResult\n  meta: {\n    syntax: 'PREFIX_QUESTION_MARK' | 'SUFFIX_QUESTION_MARK'\n  }\n}\n\nexport interface JtpNotNullableResult {\n  type: 'NOT_NULLABLE'\n  value: JtpResult\n  meta: {\n    syntax: 'PREFIX_BANG' | 'SUFFIX_BANG'\n  }\n}\n\nexport interface JtpOptionalResult {\n  type: 'OPTIONAL'\n  value: JtpResult\n  meta: {\n    syntax: 'PREFIX_EQUAL_SIGN' | 'SUFFIX_EQUALS_SIGN' | 'SUFFIX_KEY_QUESTION_MARK'\n  }\n}\n\nexport interface JtpVariadicResult {\n  type: 'VARIADIC'\n  value?: JtpResult\n  meta: {\n    syntax: 'PREFIX_DOTS' | 'SUFFIX_DOTS' | 'ONLY_DOTS'\n  }\n}\n\nexport interface JtpNameResult {\n  type: 'NAME'\n  name: string\n}\n\nexport interface JtpTypeOfResult {\n  type: 'TYPE_QUERY'\n  name?: JtpResult\n}\n\nexport interface JtpKeyOfResult {\n  type: 'KEY_QUERY'\n  value?: JtpResult\n}\n\nexport interface JtpTupleResult {\n  type: 'TUPLE'\n  entries: JtpResult[]\n}\n\nexport interface JtpStringValueResult {\n  type: 'STRING_VALUE'\n  quoteStyle: JtpQuoteStyle\n  string: string\n}\n\nexport interface JtpImportResult {\n  type: 'IMPORT'\n  path: JtpStringValueResult\n}\n\nexport interface JtpAnyResult {\n  type: 'ANY'\n}\n\nexport interface JtpUnknownResult {\n  type: 'UNKNOWN'\n}\n\nexport interface JtpFunctionResult {\n  type: 'FUNCTION' | 'ARROW'\n  params: JtpResult[]\n  returns: JtpResult | null\n  new: JtpResult | null\n  this?: JtpResult | null\n}\n\nexport interface JtpGenericResult {\n  type: 'GENERIC'\n  subject: JtpResult\n  objects: JtpResult[]\n  meta: {\n    syntax: 'ANGLE_BRACKET' | 'ANGLE_BRACKET_WITH_DOT' | 'SQUARE_BRACKET'\n  }\n}\n\nexport interface JtpRecordEntryResult {\n  type: 'RECORD_ENTRY'\n  key: string\n  quoteStyle: JtpQuoteStyle\n  value: JtpResult | null\n  readonly: false\n}\n\nexport interface JtpRecordResult {\n  type: 'RECORD'\n  entries: JtpRecordEntryResult[]\n}\n\nexport interface JtpMemberResult {\n  type: 'MEMBER' | 'INNER_MEMBER' | 'INSTANCE_MEMBER'\n  owner: JtpResult\n  name: string\n  quoteStyle: JtpQuoteStyle\n  hasEventPrefix: boolean\n}\n\nexport interface JtpUnionResult {\n  type: 'UNION'\n  left: JtpResult\n  right: JtpResult\n}\n\nexport interface JtpIntersectionResult {\n  type: 'INTERSECTION'\n  left: JtpResult\n  right: JtpResult\n}\n\nexport interface JtpParenthesisResult {\n  type: 'PARENTHESIS'\n  value: JtpResult\n}\n\nexport interface JtpNamedParameterResult {\n  type: 'NAMED_PARAMETER'\n  name: string\n  typeName: JtpResult\n}\n\nexport interface JtpModuleResult {\n  type: 'MODULE'\n  value: JtpResult\n}\n\nexport interface JtpFilePath {\n  type: 'FILE_PATH'\n  quoteStyle: JtpQuoteStyle\n  path: string\n}\n\nexport interface JtpNumberResult {\n  type: 'NUMBER_VALUE'\n  number: string\n}\n\nfunction getQuoteStyle (quote: QuoteStyle | undefined): JtpQuoteStyle {\n  switch (quote) {\n    case undefined:\n      return 'none'\n    case 'single':\n      return 'single'\n    case 'double':\n      return 'double'\n  }\n}\n\nfunction getMemberType (type: 'property' | 'inner' | 'instance' | 'property-brackets'): JtpMemberResult['type'] {\n  switch (type) {\n    case 'inner':\n      return 'INNER_MEMBER'\n    case 'instance':\n      return 'INSTANCE_MEMBER'\n    case 'property':\n      return 'MEMBER'\n    case 'property-brackets':\n      return 'MEMBER'\n  }\n}\n\nfunction nestResults (type: 'UNION' | 'INTERSECTION', results: JtpResult[]): JtpResult {\n  if (results.length === 2) {\n    return {\n      type,\n      left: results[0],\n      right: results[1]\n    }\n  } else {\n    return {\n      type,\n      left: results[0],\n      right: nestResults(type, results.slice(1))\n    }\n  }\n}\n\nconst jtpRules: TransformRules<JtpResult> = {\n  JsdocTypeOptional: (result, transform) => ({\n    type: 'OPTIONAL',\n    value: transform(result.element),\n    meta: {\n      syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n    }\n  }),\n\n  JsdocTypeNullable: (result, transform) => ({\n    type: 'NULLABLE',\n    value: transform(result.element),\n    meta: {\n      syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n    }\n  }),\n\n  JsdocTypeNotNullable: (result, transform) => ({\n    type: 'NOT_NULLABLE',\n    value: transform(result.element),\n    meta: {\n      syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n    }\n  }),\n\n  JsdocTypeVariadic: (result, transform) => {\n    const transformed: JtpVariadicResult = {\n      type: 'VARIADIC',\n      meta: {\n        syntax: result.meta.position === 'prefix'\n          ? 'PREFIX_DOTS'\n          : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n      }\n    }\n    if (result.element !== undefined) {\n      transformed.value = transform(result.element)\n    }\n\n    return transformed\n  },\n\n  JsdocTypeName: result => ({\n    type: 'NAME',\n    name: result.value\n  }),\n\n  JsdocTypeTypeof: (result, transform) => ({\n    type: 'TYPE_QUERY',\n    name: transform(result.element)\n  }),\n\n  JsdocTypeTuple: (result, transform) => ({\n    type: 'TUPLE',\n    entries: (result.elements as NonRootResult[]).map(transform)\n  }),\n\n  JsdocTypeKeyof: (result, transform) => ({\n    type: 'KEY_QUERY',\n    value: transform(result.element)\n  }),\n\n  JsdocTypeImport: result => ({\n    type: 'IMPORT',\n    path: {\n      type: 'STRING_VALUE',\n      quoteStyle: getQuoteStyle(result.element.meta.quote),\n      string: result.element.value\n    }\n  }),\n\n  JsdocTypeUndefined: () => ({\n    type: 'NAME',\n    name: 'undefined'\n  }),\n\n  JsdocTypeAny: () => ({\n    type: 'ANY'\n  }),\n\n  JsdocTypeFunction: (result, transform) => {\n    const specialParams = extractSpecialParams(result)\n\n    const transformed: JtpFunctionResult = {\n      type: result.arrow ? 'ARROW' : 'FUNCTION',\n      params: specialParams.params.map(param => {\n        if (param.type === 'JsdocTypeKeyValue') {\n          if (param.right === undefined) {\n            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'')\n          }\n          return {\n            type: 'NAMED_PARAMETER',\n            name: param.key,\n            typeName: transform(param.right)\n          }\n        } else {\n          return transform(param)\n        }\n      }),\n      new: null,\n      returns: null\n    }\n\n    if (specialParams.this !== undefined) {\n      transformed.this = transform(specialParams.this)\n    } else if (!result.arrow) {\n      transformed.this = null\n    }\n\n    if (specialParams.new !== undefined) {\n      transformed.new = transform(specialParams.new)\n    }\n\n    if (result.returnType !== undefined) {\n      transformed.returns = transform(result.returnType)\n    }\n\n    return transformed\n  },\n\n  JsdocTypeGeneric: (result, transform) => {\n    const transformed: JtpGenericResult = {\n      type: 'GENERIC',\n      subject: transform(result.left),\n      objects: result.elements.map(transform),\n      meta: {\n        syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n      }\n    }\n\n    if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n      transformed.objects[0] = {\n        type: 'NAME',\n        name: 'function'\n      }\n    }\n\n    return transformed\n  },\n\n  JsdocTypeObjectField: (result, transform) => {\n    if (typeof result.key !== 'string') {\n      throw new Error('Index signatures and mapped types are not supported')\n    }\n\n    if (result.right === undefined) {\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        value: null,\n        readonly: false\n      }\n    }\n\n    let right = transform(result.right)\n    if (result.optional) {\n      right = {\n        type: 'OPTIONAL',\n        value: right,\n        meta: {\n          syntax: 'SUFFIX_KEY_QUESTION_MARK'\n        }\n      }\n    }\n\n    return {\n      type: 'RECORD_ENTRY',\n      key: result.key,\n      quoteStyle: getQuoteStyle(result.meta.quote),\n      value: right,\n      readonly: false\n    }\n  },\n\n  JsdocTypeJsdocObjectField: () => {\n    throw new Error('Keys may not be typed in jsdoctypeparser.')\n  },\n\n  JsdocTypeKeyValue: (result, transform) => {\n    if (result.right === undefined) {\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: 'none',\n        value: null,\n        readonly: false\n      }\n    }\n\n    let right = transform(result.right)\n    if (result.optional) {\n      right = {\n        type: 'OPTIONAL',\n        value: right,\n        meta: {\n          syntax: 'SUFFIX_KEY_QUESTION_MARK'\n        }\n      }\n    }\n\n    return {\n      type: 'RECORD_ENTRY',\n      key: result.key,\n      quoteStyle: 'none',\n      value: right,\n      readonly: false\n    }\n  },\n\n  JsdocTypeObject: (result, transform) => {\n    const entries: JtpRecordEntryResult[] = []\n    for (const field of result.elements) {\n      if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n        entries.push(transform(field) as JtpRecordEntryResult)\n      }\n    }\n    return {\n      type: 'RECORD',\n      entries\n    }\n  },\n\n  JsdocTypeSpecialNamePath: result => {\n    if (result.specialType !== 'module') {\n      throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`)\n    }\n    return {\n      type: 'MODULE',\n      value: {\n        type: 'FILE_PATH',\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        path: result.value\n      }\n    }\n  },\n\n  JsdocTypeNamePath: (result, transform) => {\n    let hasEventPrefix = false\n    let name\n    let quoteStyle\n    if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n      hasEventPrefix = true\n      name = result.right.value\n      quoteStyle = getQuoteStyle(result.right.meta.quote)\n    } else {\n      name = result.right.value\n      quoteStyle = getQuoteStyle(result.right.meta.quote)\n    }\n\n    const transformed: JtpMemberResult = {\n      type: getMemberType(result.pathType),\n      owner: transform(result.left),\n      name,\n      quoteStyle,\n      hasEventPrefix\n    }\n\n    if (transformed.owner.type === 'MODULE') {\n      const tModule = transformed.owner\n      transformed.owner = transformed.owner.value\n      tModule.value = transformed\n      return tModule\n    } else {\n      return transformed\n    }\n  },\n\n  JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n\n  JsdocTypeParenthesis: (result, transform) => ({\n    type: 'PARENTHESIS',\n    value: transform(assertRootResult(result.element))\n  }),\n\n  JsdocTypeNull: () => ({\n    type: 'NAME',\n    name: 'null'\n  }),\n\n  JsdocTypeUnknown: () => ({\n    type: 'UNKNOWN'\n  }),\n\n  JsdocTypeStringValue: result => ({\n    type: 'STRING_VALUE',\n    quoteStyle: getQuoteStyle(result.meta.quote),\n    string: result.value\n  }),\n\n  JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n\n  JsdocTypeNumber: result => ({\n    type: 'NUMBER_VALUE',\n    number: result.value.toString()\n  }),\n\n  JsdocTypeSymbol: notAvailableTransform,\n\n  JsdocTypeProperty: notAvailableTransform,\n\n  JsdocTypePredicate: notAvailableTransform,\n\n  JsdocTypeMappedType: notAvailableTransform,\n\n  JsdocTypeIndexSignature: notAvailableTransform,\n\n  JsdocTypeAsserts: notAvailableTransform,\n\n  JsdocTypeReadonlyArray: notAvailableTransform,\n\n  JsdocTypeAssertsPlain: notAvailableTransform,\n\n  JsdocTypeConditional: notAvailableTransform,\n\n  JsdocTypeTypeParameter: notAvailableTransform\n}\n\nexport function jtpTransform (result: RootResult): JtpResult {\n  return transform(jtpRules, result)\n}\n","import type { TransformRules } from './transform'\nimport type {\n  JsdocObjectFieldResult,\n  KeyValueResult,\n  NonRootResult,\n  ObjectFieldResult\n} from '../result/NonRootResult'\nimport type {\n  FunctionResult,\n  NameResult,\n  StringValueResult,\n  SymbolResult,\n  RootResult,\n  VariadicResult,\n  NumberResult\n} from '../result/RootResult'\n\nexport function identityTransformRules (): TransformRules<NonRootResult> {\n  return {\n    JsdocTypeIntersection: (result, transform) => ({\n      type: 'JsdocTypeIntersection',\n      elements: result.elements.map(transform) as RootResult[]\n    }),\n\n    JsdocTypeGeneric: (result, transform) => ({\n      type: 'JsdocTypeGeneric',\n      left: transform(result.left) as RootResult,\n      elements: result.elements.map(transform) as RootResult[],\n      meta: {\n        dot: result.meta.dot,\n        brackets: result.meta.brackets\n      }\n    }),\n\n    JsdocTypeNullable: result => result,\n\n    JsdocTypeUnion: (result, transform) => ({\n      type: 'JsdocTypeUnion',\n      elements: result.elements.map(transform) as RootResult[]\n    }),\n\n    JsdocTypeUnknown: result => result,\n\n    JsdocTypeUndefined: result => result,\n\n    JsdocTypeTypeof: (result, transform) => ({\n      type: 'JsdocTypeTypeof',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeSymbol: (result, transform) => {\n      const transformed: SymbolResult = {\n        type: 'JsdocTypeSymbol',\n        value: result.value\n      }\n      if (result.element !== undefined) {\n        transformed.element = transform(result.element) as NumberResult | NameResult | VariadicResult<NameResult>\n      }\n      return transformed\n    },\n\n    JsdocTypeOptional: (result, transform) => ({\n      type: 'JsdocTypeOptional',\n      element: transform(result.element) as RootResult,\n      meta: {\n        position: result.meta.position\n      }\n    }),\n\n    JsdocTypeObject: (result, transform) => ({\n      type: 'JsdocTypeObject',\n      meta: {\n        separator: 'comma'\n      },\n      elements: result.elements.map(transform) as Array<ObjectFieldResult | JsdocObjectFieldResult>\n    }),\n\n    JsdocTypeNumber: result => result,\n\n    JsdocTypeNull: result => result,\n\n    JsdocTypeNotNullable: (result, transform) => ({\n      type: 'JsdocTypeNotNullable',\n      element: transform(result.element) as RootResult,\n      meta: {\n        position: result.meta.position\n      }\n    }),\n\n    JsdocTypeSpecialNamePath: result => result,\n\n    JsdocTypeObjectField: (result, transform) => ({\n      type: 'JsdocTypeObjectField',\n      key: result.key,\n      right: result.right === undefined ? undefined : transform(result.right) as RootResult,\n      optional: result.optional,\n      readonly: result.readonly,\n      meta: result.meta\n    }),\n\n    JsdocTypeJsdocObjectField: (result, transform) => ({\n      type: 'JsdocTypeJsdocObjectField',\n      left: transform(result.left) as RootResult,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeKeyValue: (result, transform) => ({\n      type: 'JsdocTypeKeyValue',\n      key: result.key,\n      right: result.right === undefined ? undefined : transform(result.right) as RootResult,\n      optional: result.optional,\n      variadic: result.variadic\n    }),\n\n    JsdocTypeImport: (result, transform) => ({\n      type: 'JsdocTypeImport',\n      element: transform(result.element) as StringValueResult\n    }),\n\n    JsdocTypeAny: result => result,\n\n    JsdocTypeStringValue: result => result,\n\n    JsdocTypeNamePath: result => result,\n\n    JsdocTypeVariadic: (result, transform) => {\n      const transformed: VariadicResult<RootResult> = {\n        type: 'JsdocTypeVariadic',\n        meta: {\n          position: result.meta.position,\n          squareBrackets: result.meta.squareBrackets\n        }\n      }\n\n      if (result.element !== undefined) {\n        transformed.element = transform(result.element) as RootResult\n      }\n\n      return transformed\n    },\n\n    JsdocTypeTuple: (result, transform) => ({\n      type: 'JsdocTypeTuple',\n      elements: (result.elements as NonRootResult[]).map(transform) as RootResult[] | KeyValueResult[]\n    }),\n\n    JsdocTypeName: result => result,\n\n    JsdocTypeFunction: (result, transform) => {\n      const transformed: FunctionResult = {\n        type: 'JsdocTypeFunction',\n        arrow: result.arrow,\n        parameters: result.parameters.map(transform) as RootResult[],\n        constructor: result.constructor,\n        parenthesis: result.parenthesis\n      }\n\n      if (result.returnType !== undefined) {\n        transformed.returnType = transform(result.returnType) as RootResult\n      }\n\n      return transformed\n    },\n\n    JsdocTypeKeyof: (result, transform) => ({\n      type: 'JsdocTypeKeyof',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeParenthesis: (result, transform) => ({\n      type: 'JsdocTypeParenthesis',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeProperty: result => result,\n\n    JsdocTypePredicate: (result, transform) => ({\n      type: 'JsdocTypePredicate',\n      left: transform(result.left) as NameResult,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeIndexSignature: (result, transform) => ({\n      type: 'JsdocTypeIndexSignature',\n      key: result.key,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeMappedType: (result, transform) => ({\n      type: 'JsdocTypeMappedType',\n      key: result.key,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeAsserts: (result, transform) => ({\n      type: 'JsdocTypeAsserts',\n      left: transform(result.left) as NameResult,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeReadonlyArray: (result, transform) => ({\n      type: 'JsdocTypeReadonlyArray',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeAssertsPlain: (result, transform) => ({\n      type: 'JsdocTypeAssertsPlain',\n      element: transform(result.element) as NameResult\n    }),\n\n    JsdocTypeConditional: (result, transform) => ({\n      type: 'JsdocTypeConditional',\n      checksType: transform(result.checksType) as RootResult,\n      extendsType: transform(result.extendsType) as RootResult,\n      trueType: transform(result.trueType) as RootResult,\n      falseType: transform(result.falseType) as RootResult\n    }),\n\n    JsdocTypeTypeParameter: (result, transform) => ({\n      type: 'JsdocTypeTypeParameter',\n      name: transform(result.name) as NameResult,\n      constraint: result.constraint !== undefined ? transform(result.constraint) as RootResult : undefined,\n      defaultValue: result.defaultValue !== undefined ? transform(result.defaultValue) as RootResult : undefined\n    })\n  }\n}\n","import type { NonRootResult } from './result/NonRootResult'\n\nexport type VisitorKeys = {\n  [P in NonRootResult as P['type']]: Array<keyof P>\n}\n\nexport const visitorKeys: VisitorKeys = {\n  JsdocTypeAny: [],\n  JsdocTypeFunction: ['parameters', 'returnType'],\n  JsdocTypeGeneric: ['left', 'elements'],\n  JsdocTypeImport: [],\n  JsdocTypeIndexSignature: ['right'],\n  JsdocTypeIntersection: ['elements'],\n  JsdocTypeKeyof: ['element'],\n  JsdocTypeKeyValue: ['right'],\n  JsdocTypeMappedType: ['right'],\n  JsdocTypeName: [],\n  JsdocTypeNamePath: ['left', 'right'],\n  JsdocTypeNotNullable: ['element'],\n  JsdocTypeNull: [],\n  JsdocTypeNullable: ['element'],\n  JsdocTypeNumber: [],\n  JsdocTypeObject: ['elements'],\n  JsdocTypeObjectField: ['right'],\n  JsdocTypeJsdocObjectField: ['left', 'right'],\n  JsdocTypeOptional: ['element'],\n  JsdocTypeParenthesis: ['element'],\n  JsdocTypeSpecialNamePath: [],\n  JsdocTypeStringValue: [],\n  JsdocTypeSymbol: ['element'],\n  JsdocTypeTuple: ['elements'],\n  JsdocTypeTypeof: ['element'],\n  JsdocTypeUndefined: [],\n  JsdocTypeUnion: ['elements'],\n  JsdocTypeUnknown: [],\n  JsdocTypeVariadic: ['element'],\n  JsdocTypeProperty: [],\n  JsdocTypePredicate: ['left', 'right'],\n  JsdocTypeAsserts: ['left', 'right'],\n  JsdocTypeReadonlyArray: ['element'],\n  JsdocTypeAssertsPlain: ['element'],\n  JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],\n  JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue']\n}\n","import type { NonRootResult } from './result/NonRootResult'\nimport type { RootResult } from './result/RootResult'\nimport { visitorKeys } from './visitorKeys'\n\n/**\n * A node visitor function.\n * @param node the visited node.\n * @param parentNode the parent node.\n * @param property the property on the parent node that contains the visited node. It can be the node itself or\n *  an array of nodes.\n */\nexport type NodeVisitor = (node: NonRootResult, parentNode?: NonRootResult, property?: string) => void\n\nfunction _traverse<T extends NonRootResult, U extends NonRootResult> (node: T, parentNode?: U, property?: keyof U, onEnter?: NodeVisitor, onLeave?: NodeVisitor): void {\n  onEnter?.(node, parentNode, property as string)\n\n  const keysToVisit = visitorKeys[node.type] as Array<keyof T>\n\n  for (const key of keysToVisit) {\n    const value = node[key]\n    if (value !== undefined) {\n      if (Array.isArray(value)) {\n        for (const element of value) {\n          _traverse(element as unknown as NonRootResult, node, key, onEnter, onLeave)\n        }\n      } else {\n        _traverse(value as unknown as NonRootResult, node, key, onEnter, onLeave)\n      }\n    }\n  }\n\n  onLeave?.(node, parentNode, property as string)\n}\n\n/**\n * A function to traverse an AST. It traverses it depth first.\n * @param node the node to start traversing at.\n * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n */\nexport function traverse (node: RootResult, onEnter?: NodeVisitor, onLeave?: NodeVisitor): void {\n  _traverse(node, undefined, undefined, onEnter, onLeave)\n}\n"],"mappings":"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","names":["left","pathGrammar","pathGrammar","type","objectFieldGrammar","quote","quote","objectFieldGrammar","rules","quote","transform","transform","quote","transform","transform"]}